# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2012-05-09 09:42+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: usingvalidator.xml:24
#, no-c-format
msgid "Validation step by step"
msgstr ""

#. Tag: para
#: usingvalidator.xml:26
#, no-c-format
msgid "In this chapter we will see in more detail how to use Hibernate Validator to validate constraints for a given entity model. We will also learn which default constraints the Bean Validation specification provides and which additional constraints are only provided by Hibernate Validator. Let's start with how to add constraints to an entity."
msgstr ""

#. Tag: title
#: usingvalidator.xml:33
#, no-c-format
msgid "Defining constraints"
msgstr ""

#. Tag: para
#: usingvalidator.xml:35
#, no-c-format
msgid "Constraints in Bean Validation are expressed via Java annotations. In this section we show how to annotate an object model with these annotations. We have to differentiate between three different type of constraint annotations - field-, property-, and class-level annotations."
msgstr ""

#. Tag: para
#: usingvalidator.xml:42
#, no-c-format
msgid "Not all constraints can be placed on all of these levels. In fact, none of the default constraints defined by Bean Validation can be placed at class level. The <classname>java.lang.annotation.Target</classname> annotation in the constraint annotation itself determines on which elements a constraint can be placed. See <xref linkend=\"validator-customconstraints\"/> for more information."
msgstr ""

#. Tag: title
#: usingvalidator.xml:51
#, no-c-format
msgid "Field-level constraints"
msgstr ""

#. Tag: para
#: usingvalidator.xml:53
#, no-c-format
msgid "Constraints can be expressed by annotating a field of a class. <xref linkend=\"example-field-level\"/> shows a field level configuration example:"
msgstr ""

#. Tag: title
#: usingvalidator.xml:58
#, no-c-format
msgid "Field level constraint"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:60
#, no-c-format
msgid ""
      "package com.mycompany;\n"
      "\n"
      "import javax.validation.constraints.NotNull;\n"
      "\n"
      "public class Car {\n"
      "\n"
      "    @NotNull\n"
      "    private String manufacturer;\n"
      "\n"
      "    @AssertTrue\n"
      "    private boolean isRegistered;\n"
      "\n"
      "    public Car(String manufacturer, boolean isRegistered) {\n"
      "        super();\n"
      "        this.manufacturer = manufacturer;\n"
      "        this.isRegistered = isRegistered;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:63
#, no-c-format
msgid "When using field level constraints field access strategy is used to access the value to be validated. This means the bean validation provider directly accesses the instance variable and does not invoke the property accessor method also if such a method exists."
msgstr ""

#. Tag: para
#: usingvalidator.xml:69
#, no-c-format
msgid "The access type (private, protected or public) does not matter."
msgstr ""

#. Tag: para
#: usingvalidator.xml:74
#, no-c-format
msgid "Static fields and properties cannot be validated."
msgstr ""

#. Tag: para
#: usingvalidator.xml:78
#, no-c-format
msgid "When validating byte code enhanced objects property level constraints should be used, because the byte code enhancing library won't be able to determine a field access via reflection."
msgstr ""

#. Tag: title
#: usingvalidator.xml:85
#, no-c-format
msgid "Property-level constraints"
msgstr ""

#. Tag: para
#: usingvalidator.xml:87
#, no-c-format
msgid "If your model class adheres to the <ulink type=\"\" url=\"http://java.sun.com/javase/technologies/desktop/javabeans/index.jsp\">JavaBeans</ulink> standard, it is also possible to annotate the properties of a bean class instead of its fields. <xref linkend=\"example-property-level\"/> uses the same entity as in <xref linkend=\"example-field-level\"/>, however, property level constraints are used."
msgstr ""

#. Tag: para
#: usingvalidator.xml:93
#, no-c-format
msgid "The property's getter method has to be annotated, not its setter."
msgstr ""

#. Tag: title
#: usingvalidator.xml:98
#, no-c-format
msgid "Property level constraint"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:100
#, no-c-format
msgid ""
      "package com.mycompany;\n"
      "\n"
      "import javax.validation.constraints.AssertTrue;\n"
      "import javax.validation.constraints.NotNull;\n"
      "\n"
      "public class Car {\n"
      "\n"
      "    private String manufacturer;\n"
      "\n"
      "    private boolean isRegistered;\n"
      "      \n"
      "    public Car(String manufacturer, boolean isRegistered) {\n"
      "        super();\n"
      "        this.manufacturer = manufacturer;\n"
      "        this.isRegistered = isRegistered;\n"
      "    }\n"
      "\n"
      "    @NotNull\n"
      "    public String getManufacturer() {\n"
      "        return manufacturer;\n"
      "    }\n"
      "\n"
      "    public void setManufacturer(String manufacturer) {\n"
      "        this.manufacturer = manufacturer;\n"
      "    }\n"
      "\n"
      "    @AssertTrue\n"
      "    public boolean isRegistered() {\n"
      "        return isRegistered;\n"
      "    }\n"
      "\n"
      "    public void setRegistered(boolean isRegistered) {\n"
      "        this.isRegistered = isRegistered;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:103
#, no-c-format
msgid "When using property level constraints property access strategy is used to access the value to be validated. This means the bean validation provider accesses the state via the property accessor method. One advantage of annotating properties instead of fields is that the constraints become part of the constrained type's API that way and users are aware of the existing constraints without having to examine the type's implementation."
msgstr ""

#. Tag: para
#: usingvalidator.xml:112
#, no-c-format
msgid "It is recommended to stick either to field <emphasis>or</emphasis> property annotations within one class. It is not recommended to annotate a field <emphasis>and</emphasis> the accompanying getter method as this would cause the field to be validated twice."
msgstr ""

#. Tag: title
#: usingvalidator.xml:121
#, no-c-format
msgid "Class-level constraints"
msgstr ""

#. Tag: para
#: usingvalidator.xml:124
#, no-c-format
msgid "Last but not least, a constraint can also be placed on class level. When a constraint annotation is placed on this level the class instance itself passed to the <classname>ConstraintValidator</classname>. Class level constraints are useful if it is necessary to inspect more than a single property of the class to validate it or if a correlation between different state variables has to be evaluated. In <xref linkend=\"example-class-level\"/> we add the property <property>passengers</property> to the class <classname>Car</classname>. We also add the constraint <classname>PassengerCount</classname> on the class level. We will later see how we can actually create this custom constraint (see <xref linkend=\"validator-customconstraints\"/>). For now it is enough to know that <classname>PassengerCount</classname> will ensure that there cannot be more passengers in a car than there are seats."
msgstr ""

#. Tag: title
#: usingvalidator.xml:140
#, no-c-format
msgid "Class level constraint"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:142
#, no-c-format
msgid ""
      "package com.mycompany;\n"
      "\n"
      "import javax.validation.constraints.Min;\n"
      "import javax.validation.constraints.NotNull;\n"
      "import javax.validation.constraints.Size;\n"
      "\n"
      "@PassengerCount\n"
      "public class Car {\n"
      "\n"
      "    @NotNull\n"
      "    private String manufacturer;\n"
      "\n"
      "    @NotNull\n"
      "    @Size(min = 2, max = 14)\n"
      "    private String licensePlate;\n"
      "\n"
      "    @Min(2)\n"
      "    private int seatCount;\n"
      "    \n"
      "    private List&lt;Person&gt; passengers;\n"
      "    \n"
      "    public Car(String manufacturer, String licencePlate, int seatCount) {\n"
      "        this.manufacturer = manufacturer;\n"
      "        this.licensePlate = licencePlate;\n"
      "        this.seatCount = seatCount;\n"
      "    }\n"
      "\n"
      "    //getters and setters ...\n"
      "}"
msgstr ""

#. Tag: title
#: usingvalidator.xml:147
#, no-c-format
msgid "Constraint inheritance"
msgstr ""

#. Tag: para
#: usingvalidator.xml:149
#, no-c-format
msgid "When validating an object that implements an interface or extends another class, all constraint annotations on the implemented interface and parent class apply in the same manner as the constraints specified on the validated object itself. To make things clearer let's have a look at the following example:"
msgstr ""

#. Tag: title
#: usingvalidator.xml:156
#, no-c-format
msgid "Constraint inheritance using RentalCar"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:158
#, no-c-format
msgid ""
      "package com.mycompany;\n"
      "\n"
      "import javax.validation.constraints.NotNull;\n"
      "\n"
      "public class RentalCar extends Car {\n"
      "\n"
      "    private String rentalStation;\n"
      "    \n"
      "    public RentalCar(String manufacturer, String rentalStation) {\n"
      "        super(manufacturer);\n"
      "        this.rentalStation = rentalStation;\n"
      "    }\n"
      "    \n"
      "    @NotNull\n"
      "    public String getRentalStation() {\n"
      "        return rentalStation;\n"
      "    }\n"
      "\n"
      "    public void setRentalStation(String rentalStation) {\n"
      "        this.rentalStation = rentalStation;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:161
#, no-c-format
msgid "Our well-known class <classname>Car</classname> is now extended by <classname>RentalCar</classname> with the additional property <property>rentalStation</property>. If an instance of <classname>RentalCar</classname> is validated, not only the <classname>@NotNull</classname> constraint on <property>rentalStation</property> is validated, but also the constraint on <property>manufacturer</property> from the parent class."
msgstr ""

#. Tag: para
#: usingvalidator.xml:169
#, no-c-format
msgid "The same would hold true, if <classname>Car</classname> were an interface implemented by <classname>RentalCar</classname>."
msgstr ""

#. Tag: para
#: usingvalidator.xml:172
#, no-c-format
msgid "Constraint annotations are aggregated if methods are overridden. If <classname>RentalCar</classname> would override the <methodname>getManufacturer()</methodname> method from <classname>Car</classname> any constraints annotated at the overriding method would be evaluated in addition to the <classname>@NotNull</classname> constraint from the super-class."
msgstr ""

#. Tag: title
#: usingvalidator.xml:181
#, no-c-format
msgid "Object graphs"
msgstr ""

#. Tag: para
#: usingvalidator.xml:183
#, no-c-format
msgid "The Bean Validation API does not only allow to validate single class instances but also complete object graphs. To do so, just annotate a field or property representing a reference to another object with <classname>@Valid</classname>. If the parent object is validated, all referenced objects annotated with <classname>@Valid</classname> will be validated as well (as will be their children etc.). See <xref linkend=\"example-car-with-driver\"/>."
msgstr ""

#. Tag: title
#: usingvalidator.xml:192
#, no-c-format
msgid "Class Person"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:194
#, no-c-format
msgid ""
      "package com.mycompany;\n"
      "\n"
      "import javax.validation.constraints.NotNull;\n"
      "\n"
      "public class Person {\n"
      "\n"
      "    @NotNull\n"
      "    private String name;\n"
      "    \n"
      "    public Person(String name) {\n"
      "        super();\n"
      "        this.name = name;\n"
      "    }\n"
      "\n"
      "    public String getName() {\n"
      "        return name;\n"
      "    }\n"
      "\n"
      "    public void setName(String name) {\n"
      "        this.name = name;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: title
#: usingvalidator.xml:198
#, no-c-format
msgid "Adding a driver to the car"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:200
#, no-c-format
msgid ""
      "package com.mycompany;\n"
      "\n"
      "import javax.validation.Valid;\n"
      "import javax.validation.constraints.NotNull;\n"
      "\n"
      "public class Car {\n"
      "\n"
      "    @NotNull\n"
      "    @Valid\n"
      "    private Person driver;\n"
      "    \n"
      "    public Car(Person driver) {\n"
      "        this.driver = driver;\n"
      "    }\n"
      "\n"
      "    //getters and setters ...\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:203
#, no-c-format
msgid "If an instance of <classname>Car</classname> is validated, the referenced <classname>Person</classname> object will be validated as well, as the <property>driver</property> field is annotated with <classname>@Valid</classname>. Therefore the validation of a <classname>Car</classname> will fail if the <property>name</property> field of the referenced <classname>Person</classname> instance is <code>null</code>."
msgstr ""

#. Tag: para
#: usingvalidator.xml:211
#, no-c-format
msgid "Object graph validation also works for collection-typed fields. That means any attributes that"
msgstr ""

#. Tag: para
#: usingvalidator.xml:216
#, no-c-format
msgid "are arrays"
msgstr ""

#. Tag: para
#: usingvalidator.xml:220
#, no-c-format
msgid "implement <classname>java.lang.Iterable</classname> (especially <classname>Collection</classname>, <classname>List</classname> and <classname>Set</classname>)"
msgstr ""

#. Tag: para
#: usingvalidator.xml:226
#, no-c-format
msgid "implement <classname>java.util.Map</classname>"
msgstr ""

#. Tag: para
#: usingvalidator.xml:230
#, no-c-format
msgid "can be annotated with <classname>@Valid</classname>, which will cause each contained element to be validated, when the parent object is validated."
msgstr ""

#. Tag: title
#: usingvalidator.xml:235
#, no-c-format
msgid "Car with a list of passengers"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:237
#, no-c-format
msgid ""
      "package com.mycompany;\n"
      "\n"
      "import java.util.ArrayList;\n"
      "import java.util.List;\n"
      "\n"
      "import javax.validation.Valid;\n"
      "import javax.validation.constraints.NotNull;\n"
      "\n"
      "public class Car {\n"
      "\n"
      "    @NotNull\n"
      "    @Valid\n"
      "    private List&lt;Person&gt; passengers = new ArrayList&lt;Person&gt;();\n"
      "\n"
      "    public Car(List&lt;Person&gt; passengers) {\n"
      "        this.passengers = passengers;\n"
      "    }\n"
      "\n"
      "    //getters and setters ...\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:240
#, no-c-format
msgid "If a <classname>Car</classname> instance is validated, a <classname>ConstraintValidation</classname> will be created, if any of the <classname>Person</classname> objects contained in the <property>passengers</property> list has a <code>null</code> name."
msgstr ""

#. Tag: para
#: usingvalidator.xml:244
#, no-c-format
msgid "<classname>null</classname> values are getting ignored when validating object graphs."
msgstr ""

#. Tag: title
#: usingvalidator.xml:251
#, no-c-format
msgid "Validating constraints"
msgstr ""

#. Tag: para
#: usingvalidator.xml:253
#, no-c-format
msgid "The <classname>Validator</classname> interface is the main entry point to Bean Validation. In <xref linkend=\"section-validator-instance\"/> we will first show how to obtain an <classname>Validator</classname> instance. Afterwards we will learn how to use the different methods of the <classname>Validator</classname> interface."
msgstr ""

#. Tag: title
#: usingvalidator.xml:260
#, no-c-format
msgid "Obtaining a <classname>Validator</classname> instance"
msgstr ""

#. Tag: para
#: usingvalidator.xml:262
#, no-c-format
msgid "The first step towards validating an entity instance is to get hold of a <classname>Validator</classname> instance. The road to this instance leads via the <classname>Validation</classname> class and a <classname>ValidatorFactory</classname>. The easiest way is to use the static <methodname>Validation.buildDefaultValidatorFactory()</methodname> method:"
msgstr ""

#. Tag: title
#: usingvalidator.xml:271
#, no-c-format
msgid "Validation.buildDefaultValidatorFactory()"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:273
#, no-c-format
msgid ""
      "ValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n"
      "Validator validator = factory.getValidator();"
msgstr ""

#. Tag: para
#: usingvalidator.xml:276
#, no-c-format
msgid "For other ways of obtaining a Validator instance see <xref linkend=\"validator-bootstrapping\"/>. For now we just want to see how we can use the <classname>Validator</classname> instance to validate entity instances."
msgstr ""

#. Tag: title
#: usingvalidator.xml:283
#, no-c-format
msgid "Validator methods"
msgstr ""

#. Tag: para
#: usingvalidator.xml:285
#, no-c-format
msgid "The <classname>Validator</classname> interface contains three methods that can be used to either validate entire entities or just a single properties of the entity."
msgstr ""

#. Tag: para
#: usingvalidator.xml:289
#, no-c-format
msgid "All three methods return a <classname>Set&lt;ConstraintViolation&gt;</classname>. The set is empty, if the validation succeeds. Otherwise a <classname>ConstraintViolation</classname> instance is added for each violated constraint."
msgstr ""

#. Tag: para
#: usingvalidator.xml:295
#, no-c-format
msgid "All the validation methods have a var-args parameter which can be used to specify, which validation groups shall be considered when performing the validation. If the parameter is not specified the default validation group (<classname>javax.validation.groups.Default</classname>) will be used. We will go into more detail on the topic of validation groups in"
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:304
#, no-c-format
msgid "validate"
msgstr ""

#. Tag: para
#: usingvalidator.xml:306
#, no-c-format
msgid "Use the <methodname>validate()</methodname> method to perform validation of all constraints of a given entity instance (see <xref linkend=\"example-validator-validate\"/> )."
msgstr ""

#. Tag: title
#: usingvalidator.xml:311
#, no-c-format
msgid "Usage of <methodname>Validator.validate()</methodname>"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:314
#, no-c-format
msgid ""
      "ValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n"
      "Validator validator = factory.getValidator();\n"
      "\n"
      "Car car = new Car(null);\n"
      "\n"
      "Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate(car);\n"
      "\n"
      "assertEquals(1, constraintViolations.size());\n"
      "assertEquals(\"may not be null\", constraintViolations.iterator().next().getMessage());"
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:319
#, no-c-format
msgid "validateProperty"
msgstr ""

#. Tag: para
#: usingvalidator.xml:321
#, no-c-format
msgid "With help of the <methodname>validateProperty()</methodname> a single named property of a given object can be validated. The property name is the JavaBeans property name."
msgstr ""

#. Tag: title
#: usingvalidator.xml:326
#, no-c-format
msgid "Usage of <methodname>Validator.validateProperty()</methodname>"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:329
#, no-c-format
msgid ""
      "Validator validator = Validation.buildDefaultValidatorFactory().getValidator();\n"
      "\n"
      "Car car = new Car(null);\n"
      "\n"
      "Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validateProperty(car, \"manufacturer\");\n"
      "\n"
      "assertEquals(1, constraintViolations.size());\n"
      "assertEquals(\"may not be null\", constraintViolations.iterator().next().getMessage());"
msgstr ""

#. Tag: para
#: usingvalidator.xml:332
#, no-c-format
msgid "<methodname>Validator.validateProperty</methodname> is for example used in the integration of Bean Validation into JSF 2 (see <xref linkend=\"section-presentation-layer\"/>)."
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:338
#, no-c-format
msgid "validateValue"
msgstr ""

#. Tag: para
#: usingvalidator.xml:340
#, no-c-format
msgid "Using the <methodname>validateValue() </methodname>method you can check, whether a single property of a given class can be validated successfully, if the property had the specified value:"
msgstr ""

#. Tag: title
#: usingvalidator.xml:345
#, no-c-format
msgid "Usage of <methodname>Validator.validateValue()</methodname>"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:348
#, no-c-format
msgid ""
      "Validator validator = Validation.buildDefaultValidatorFactory().getValidator();\n"
      "\n"
      "Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validateValue(Car.class, \"manufacturer\", null);\n"
      "\n"
      "assertEquals(1, constraintViolations.size());\n"
      "assertEquals(\"may not be null\", constraintViolations.iterator().next().getMessage());"
msgstr ""

#. Tag: para
#: usingvalidator.xml:352
#, no-c-format
msgid "<classname>@Valid</classname> is not honored by <methodname>validateProperty()</methodname> or <methodname>validateValue()</methodname>."
msgstr ""

#. Tag: title
#: usingvalidator.xml:360
#, no-c-format
msgid "<classname>ConstraintViolation</classname> methods"
msgstr ""

#. Tag: para
#: usingvalidator.xml:362
#, no-c-format
msgid "Now it is time to have a closer look at what a <classname>ConstraintViolation</classname>. Using the different methods of <classname>ConstraintViolation</classname> a lot of useful information about the cause of the validation failure can be determined. <xref linkend=\"table-constraint-violation\"/> gives an overview of these methods:"
msgstr ""

#. Tag: title
#: usingvalidator.xml:370
#, no-c-format
msgid "The various <classname>ConstraintViolation</classname> methods"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:376
#, no-c-format
msgid "Method"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:378
#, no-c-format
msgid "Usage"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:380
#, no-c-format
msgid "Example (referring to <xref linkend=\"example-validator-validate\"/>)"
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:387
#, no-c-format
msgid "getMessage()"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:389
#, no-c-format
msgid "The interpolated error message."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:391
#, no-c-format
msgid "may not be null"
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:395
#, no-c-format
msgid "getMessageTemplate()"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:397
#, no-c-format
msgid "The non-interpolated error message."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:399
#, no-c-format
msgid "{javax.validation.constraints.NotNull.message}"
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:403
#, no-c-format
msgid "getRootBean()"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:405
#, no-c-format
msgid "The root bean being validated."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:407 usingvalidator.xml:425
#, no-c-format
msgid "<entry>car</entry>"
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:411
#, no-c-format
msgid "getRootBeanClass()"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:413
#, no-c-format
msgid "The class of the root bean being validated."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:415
#, no-c-format
msgid "Car.class"
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:419
#, no-c-format
msgid "getLeafBean()"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:421
#, no-c-format
msgid "If a bean constraint, the bean instance the constraint is applied on. If a property constraint, the bean instance hosting the property the constraint is applied on."
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:429
#, no-c-format
msgid "getPropertyPath()"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:431
#, no-c-format
msgid "The property path to the value from root bean."
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:437
#, no-c-format
msgid "getInvalidValue()"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:439
#, no-c-format
msgid "The value failing to pass the constraint."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:441
#, no-c-format
msgid "passengers"
msgstr ""

#. Tag: methodname
#: usingvalidator.xml:445
#, no-c-format
msgid "getConstraintDescriptor()"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:447
#, no-c-format
msgid "Constraint metadata reported to fail."
msgstr ""

#. Tag: title
#: usingvalidator.xml:457
#, no-c-format
msgid "Message interpolation"
msgstr ""

#. Tag: para
#: usingvalidator.xml:459
#, no-c-format
msgid "As we will see in <xref linkend=\"validator-customconstraints\"/> each constraint definition must define a default message descriptor. This message can be overridden at declaration time using the <methodname>message</methodname> attribute of the constraint. You can see this in <xref linkend=\"example-driver\"/>. This message descriptors get interpolated when a constraint validation fails using the configured <classname>MessageInterpolator</classname>. The interpolator will try to resolve any message parameters, meaning string literals enclosed in braces. In order to resolve these parameters Hibernate Validator's default <classname>MessageInterpolator</classname> first recursively resolves parameters against a custom <classname>ResourceBundle</classname> called <filename>ValidationMessages.properties</filename> at the root of the classpath (It is up to you to create this file). If no further replacements are possible against the custom bundle the default <classname>ResourceBundle</classname> under <filename>/org/hibernate/validator/ValidationMessages.properties</filename> gets evaluated. If a replacement occurs against the default bundle the algorithm looks again at the custom bundle (and so on). Once no further replacements against these two resource bundles are possible remaining parameters are getting resolved against the attributes of the constraint to be validated."
msgstr ""

#. Tag: para
#: usingvalidator.xml:482
#, no-c-format
msgid "Since the braces { and } have special meaning in the messages they need to be escaped if they are used literally. The following The following rules apply:"
msgstr ""

#. Tag: para
#: usingvalidator.xml:486
#, no-c-format
msgid "\\{ is considered as the literal {"
msgstr ""

#. Tag: para
#: usingvalidator.xml:490
#, no-c-format
msgid "\\} is considered as the literal }"
msgstr ""

#. Tag: para
#: usingvalidator.xml:494
#, no-c-format
msgid "\\\\ is considered as the literal \\"
msgstr ""

#. Tag: para
#: usingvalidator.xml:498
#, no-c-format
msgid "If the default message interpolator does not fit your requirements it is possible to plug a custom <classname>MessageInterpolator</classname> when the <classname>ValidatorFactory</classname> gets created. This can be seen in <xref linkend=\"validator-bootstrapping\"/>."
msgstr ""

#. Tag: title
#: usingvalidator.xml:507
#, no-c-format
msgid "Validating groups"
msgstr ""

#. Tag: para
#: usingvalidator.xml:509
#, no-c-format
msgid "Groups allow you to restrict the set of constraints applied during validation. This makes for example wizard like validation possible where in each step only a specified subset of constraints get validated. The groups targeted are passed as var-args parameters to <methodname>validate</methodname>, <methodname>validateProperty</methodname> and <methodname>validateValue</methodname>. Let's have a look at an extended <classname>Car</classname> with <classname>Driver</classname> example. First we have the class <classname>Person</classname> (<xref linkend=\"example-person\"/>) which has a <classname>@NotNull </classname>constraint on <property>name</property>. Since no group is specified for this annotation its default group is <classname>javax.validation.groups.Default</classname>."
msgstr ""

#. Tag: para
#: usingvalidator.xml:524
#, no-c-format
msgid "When more than one group is requested, the order in which the groups are evaluated is not deterministic. If no group is specified the default group <classname>javax.validation.groups.Default</classname> is assumed."
msgstr ""

#. Tag: title
#: usingvalidator.xml:531
#, no-c-format
msgid "Person"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:533
#, no-c-format
msgid ""
      "public class Person {\n"
      "    @NotNull\n"
      "    private String name;\n"
      "\n"
      "    public Person(String name) {\n"
      "        this.name = name;\n"
      "    }\n"
      "    // getters and setters ...\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:536
#, no-c-format
msgid "Next we have the class <classname>Driver</classname> (<xref linkend=\"example-driver\"/>) extending <classname>Person</classname>. Here we are adding the properties <property>age</property> and <property>hasDrivingLicense</property>. In order to drive you must be at least 18 (<classname>@Min(18)</classname>) and you must have a driving license (<classname>@AssertTrue</classname>). Both constraints defined on these properties belong to the group <classname>DriverChecks</classname>. As you can see in <xref linkend=\"example-group-interfaces\"/> the group <classname>DriverChecks</classname> is just a simple tagging interface. Using interfaces makes the usage of groups type safe and allows for easy refactoring. It also means that groups can inherit from each other via class inheritance."
msgstr ""

#. Tag: title
#: usingvalidator.xml:550
#, no-c-format
msgid "Driver"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:552
#, no-c-format
msgid ""
      "public class Driver extends Person {\n"
      "    @Min(value = 18, message = \"You have to be 18 to drive a car\", groups = DriverChecks.class)\n"
      "    public int age;\n"
      "\n"
      "    @AssertTrue(message = \"You first have to pass the driving test\", groups = DriverChecks.class)\n"
      "    public boolean hasDrivingLicense;\n"
      "\n"
      "    public Driver(String name) {\n"
      "        super( name );\n"
      "    }\n"
      "\n"
      "    public void passedDrivingTest(boolean b) {\n"
      "        hasDrivingLicense = b;\n"
      "    }\n"
      "\n"
      "    public int getAge() {\n"
      "        return age;\n"
      "    }\n"
      "\n"
      "    public void setAge(int age) {\n"
      "        this.age = age;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: title
#: usingvalidator.xml:556
#, no-c-format
msgid "Group interfaces"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:558
#, no-c-format
msgid ""
      "public interface DriverChecks {\n"
      "}\n"
      "\n"
      "public interface CarChecks {\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:561
#, no-c-format
msgid "Last but not least we add the property <property>passedVehicleInspection</property> to the <classname>Car</classname> class (<xref linkend=\"example-car\"/>) indicating whether a car passed the road worthy tests."
msgstr ""

#. Tag: title
#: usingvalidator.xml:567
#, no-c-format
msgid "<title>Car</title>"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:569
#, no-c-format
msgid ""
      "public class Car {\n"
      "    @NotNull\n"
      "    private String manufacturer;\n"
      "\n"
      "    @NotNull\n"
      "    @Size(min = 2, max = 14)\n"
      "    private String licensePlate;\n"
      "\n"
      "    @Min(2)\n"
      "    private int seatCount;\n"
      "\n"
      "    @AssertTrue(message = \"The car has to pass the vehicle inspection first\", groups = CarChecks.class)\n"
      "    private boolean passedVehicleInspection;\n"
      "\n"
      "    @Valid\n"
      "    private Driver driver;\n"
      "\n"
      "    public Car(String manufacturer, String licencePlate, int seatCount) {\n"
      "        this.manufacturer = manufacturer;\n"
      "        this.licensePlate = licencePlate;\n"
      "        this.seatCount = seatCount;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:572
#, no-c-format
msgid "Overall three different groups are used in our example. <property>Person.name</property>, <property>Car.manufacturer</property>, <property>Car.licensePlate</property> and <property>Car.seatCount</property> all belong to the <classname>Default</classname> group. <property>Driver.age</property> and <property>Driver.hasDrivingLicense</property> belong to <classname>DriverChecks</classname> and last but not least <property>Car.passedVehicleInspection</property> belongs to the group <classname>CarChecks</classname>. <xref linkend=\"example-drive-away\"/> shows how passing different group combinations to the <methodname>Validator.validate</methodname> method result in different validation results."
msgstr ""

#. Tag: title
#: usingvalidator.xml:586
#, no-c-format
msgid "Drive away"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:588
#, no-c-format
msgid ""
      "public class GroupTest {\n"
      "\n"
      "    private static Validator validator;\n"
      "\n"
      "    @BeforeClass\n"
      "    public static void setUp() {\n"
      "        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n"
      "        validator = factory.getValidator();\n"
      "    }\n"
      "\n"
      "    @Test\n"
      "    public void driveAway() {\n"
      "        // create a car and check that everything is ok with it.\n"
      "        Car car = new Car( \"Morris\", \"DD-AB-123\", 2 );\n"
      "        Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );\n"
      "        assertEquals( 0, constraintViolations.size() );\n"
      "\n"
      "        // but has it passed the vehicle inspection?\n"
      "        constraintViolations = validator.validate( car, CarChecks.class );\n"
      "        assertEquals( 1, constraintViolations.size() );\n"
      "        assertEquals(\"The car has to pass the vehicle inspection first\", constraintViolations.iterator().next().getMessage());\n"
      "\n"
      "        // let's go to the vehicle inspection\n"
      "        car.setPassedVehicleInspection( true );\n"
      "        assertEquals( 0, validator.validate( car ).size() );\n"
      "\n"
      "        // now let's add a driver. He is 18, but has not passed the driving test yet\n"
      "        Driver john = new Driver( \"John Doe\" );\n"
      "        john.setAge( 18 );\n"
      "        car.setDriver( john );\n"
      "        constraintViolations = validator.validate( car, DriverChecks.class );\n"
      "        assertEquals( 1, constraintViolations.size() );\n"
      "        assertEquals( \"You first have to pass the driving test\", constraintViolations.iterator().next().getMessage() );\n"
      "\n"
      "        // ok, John passes the test\n"
      "        john.passedDrivingTest( true );\n"
      "        assertEquals( 0, validator.validate( car, DriverChecks.class ).size() );\n"
      "\n"
      "        // just checking that everything is in order now\n"
      "        assertEquals( 0, validator.validate( car, Default.class, CarChecks.class, DriverChecks.class ).size() );\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:591
#, no-c-format
msgid "First we create a car and validate it using no explicit group. There are no validation errors, even though the property <property>passedVehicleInspection</property> is per default <constant>false</constant>. However, the constraint defined on this property does not belong to the default group. Next we just validate the <classname>CarChecks</classname> group which will fail until we make sure that the car passes the vehicle inspection. When we then add a driver to the car and validate against <classname>DriverChecks</classname> we get again a constraint violation due to the fact that the driver has not yet passed the driving test. Only after setting <property>passedDrivingTest</property> to true the validation against <classname>DriverChecks</classname> will pass."
msgstr ""

#. Tag: para
#: usingvalidator.xml:604
#, no-c-format
msgid "Last but not least, we show that all constraints are passing by validating against all defined groups."
msgstr ""

#. Tag: title
#: usingvalidator.xml:608
#, no-c-format
msgid "Group sequences"
msgstr ""

#. Tag: para
#: usingvalidator.xml:610
#, no-c-format
msgid "By default, constraints are evaluated in no particular order, regardless of which groups they belong to. In some situations, however, it is useful to control the order constraints are evaluated. In our example from <xref linkend=\"validator-usingvalidator-validationgroups\"/> we could for example require that first all default car constraints are passing before we check the road worthiness of the car. Finally before we drive away we check the actual driver constraints. In order to implement such an order one would define a new interface and annotate it with <classname>@GroupSequence</classname> defining the order in which the groups have to be validated."
msgstr ""

#. Tag: para
#: usingvalidator.xml:622
#, no-c-format
msgid "If at least one constraint fails in a sequenced group none of the constraints of the following groups in the sequence get validated."
msgstr ""

#. Tag: title
#: usingvalidator.xml:628
#, no-c-format
msgid "Interface with @GroupSequence"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:630
#, no-c-format
msgid ""
      "@GroupSequence({Default.class, CarChecks.class, DriverChecks.class})\n"
      "public interface OrderedChecks {\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:634
#, no-c-format
msgid "Groups defining a sequence and groups composing a sequence must not be involved in a cyclic dependency either directly or indirectly, either through cascaded sequence definition or group inheritance. If a group containing such a circularity is evaluated, a <classname>GroupDefinitionException</classname> is raised."
msgstr ""

#. Tag: para
#: usingvalidator.xml:638
#, no-c-format
msgid "The usage of the new sequence could then look like in <xref linkend=\"example-group-sequence\"/>."
msgstr ""

#. Tag: title
#: usingvalidator.xml:643
#, no-c-format
msgid "Usage of a group sequence"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:645
#, no-c-format
msgid ""
      "@Test\n"
      "public void testOrderedChecks() {\n"
      "    Car car = new Car( \"Morris\", \"DD-AB-123\", 2 );\n"
      "    car.setPassedVehicleInspection( true );\n"
      "\n"
      "    Driver john = new Driver( \"John Doe\" );\n"
      "    john.setAge( 18 );\n"
      "    john.passedDrivingTest( true );\n"
      "    car.setDriver( john );\n"
      "\n"
      "    assertEquals( 0, validator.validate( car, OrderedChecks.class ).size() );\n"
      "}"
msgstr ""

#. Tag: title
#: usingvalidator.xml:650
#, no-c-format
msgid "Redefining the default group sequence of a class"
msgstr ""

#. Tag: title
#: usingvalidator.xml:653
#, no-c-format
msgid "@GroupSequence"
msgstr ""

#. Tag: para
#: usingvalidator.xml:655
#, no-c-format
msgid "The <classname>@GroupSequence</classname> annotation also fulfills a second purpose. It allows you to redefine what the <constant>Default</constant> group means for a given class. To redefine <classname>Default</classname> for a given class, add a <classname>@GroupSequence</classname> annotation to the class. The defined groups in the annotation express the sequence of groups that substitute <classname>Default</classname> for this class. <xref linkend=\"example-rental-car\"/> introduces a new class <classname>RentalCar</classname> with a redefined default group. With this definition you can evaluate the constraints belonging to <classname>RentalChecks</classname>, <classname>CarChecks</classname> and <classname>RentalCar</classname> by just requesting the <classname>Default</classname> group as seen in <xref linkend=\"example-testCarIsRented\"/>."
msgstr ""

#. Tag: title
#: usingvalidator.xml:671
#, no-c-format
msgid "RentalCar with @GroupSequence"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:673
#, no-c-format
msgid ""
      "@GroupSequence({ RentalChecks.class, CarChecks.class, RentalCar.class })\n"
      "public class RentalCar extends Car {\n"
      "    @AssertFalse(message = \"The car is currently rented out\", groups = RentalChecks.class)\n"
      "    private boolean rented;\n"
      "\n"
      "    public RentalCar(String manufacturer, String licencePlate, int seatCount) {\n"
      "        super( manufacturer, licencePlate, seatCount );\n"
      "    }\n"
      "\n"
      "    public boolean isRented() {\n"
      "        return rented;\n"
      "    }\n"
      "\n"
      "    public void setRented(boolean rented) {\n"
      "        this.rented = rented;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: title
#: usingvalidator.xml:677
#, no-c-format
msgid "RentalCar with redefined default group"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:679
#, no-c-format
msgid ""
      "/**\n"
      " * Validating the default group leads to validation on the default group sequence of {@code RentalCar}.\n"
      " */\n"
      "@Test\n"
      "public void carIsRented() {\n"
      "  RentalCar rentalCar = new RentalCar( \"Morris\", \"DD-AB-123\", 2 );\n"
      "  rentalCar.setPassedVehicleInspection( true );\n"
      "  rentalCar.setRented( true );\n"
      "\n"
      "  Set&lt;ConstraintViolation&lt;RentalCar&gt;&gt; constraintViolations = validator.validate( rentalCar );\n"
      "\n"
      "  assertEquals( 1, constraintViolations.size() );\n"
      "  assertEquals(\n"
      "    \"Wrong message\",\n"
      "    \"The car is currently rented out\",\n"
      "    constraintViolations.iterator().next().getMessage()\n"
      "  );\n"
      "\n"
      "  rentalCar.setRented( false );\n"
      "  constraintViolations = validator.validate( rentalCar );\n"
      "\n"
      "  assertEquals( 0, constraintViolations.size() );\n"
      "}"
msgstr ""

#. Tag: para
#: usingvalidator.xml:683
#, no-c-format
msgid "Due to the fact that there cannot be a cyclic dependency in the group and group sequence definitions one cannot just add <classname>Default</classname> to the sequence redefining <classname>Default</classname> for a class. Instead the class itself has to be added!"
msgstr ""

#. Tag: para
#: usingvalidator.xml:691
#, no-c-format
msgid "The <classname>Default</classname> group sequence overriding is local to the class it is defined on and is not propagated to the associated objects. This means in particular that adding <classname>DriverChecks</classname> to the default group sequence of <classname>RentalCar</classname> would not have any effects. Only the group <classname>Default</classname> will be propagated to the driver association when validation a rental car instance."
msgstr ""

#. Tag: title
#: usingvalidator.xml:702
#, no-c-format
msgid "@GroupSequenceProvider"
msgstr ""

#. Tag: para
#: usingvalidator.xml:704
#, no-c-format
msgid "The <classname>@javax.validation.GroupSequence</classname> annotation is a standardized Bean Validation annotation. As seen in the previous section it allows you to statically redefine the default group sequence for a class. Hibernate Validator also offers a custom, non standardized annotation - <classname>org.hibernate.validator.group.GroupSequenceProvider </classname>- which allows for dynamic redefinition of the default group sequence. Using the rental car scenario again, one could dynamically add the <classname>CarChecks</classname> as seen in <xref linkend=\"example-rental-car-group-sequence-provider\"/> and <xref linkend=\"example-group-sequence-provider-implementation\"/>."
msgstr ""

#. Tag: title
#: usingvalidator.xml:717
#, no-c-format
msgid "RentalCar with @GroupSequenceProvider"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:719
#, no-c-format
msgid ""
      "@GroupSequenceProvider(RentalCarGroupSequenceProvider.class)\n"
      "public class RentalCar extends Car {\n"
      "    @AssertFalse(message = \"The car is currently rented out\", groups = RentalChecks.class)\n"
      "    private boolean rented;\n"
      "\n"
      "    public RentalCar(String manufacturer, String licencePlate, int seatCount) {\n"
      "        super( manufacturer, licencePlate, seatCount );\n"
      "    }\n"
      "\n"
      "    public boolean isRented() {\n"
      "        return rented;\n"
      "    }\n"
      "\n"
      "    public void setRented(boolean rented) {\n"
      "        this.rented = rented;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: title
#: usingvalidator.xml:723
#, no-c-format
msgid "DefaultGroupSequenceProvider implementation"
msgstr ""

#. Tag: programlisting
#: usingvalidator.xml:725
#, no-c-format
msgid ""
      "public class RentalCarGroupSequenceProvider implements DefaultGroupSequenceProvider&lt;RentalCar&gt; {\n"
      "    public List&lt;Class&lt;?&gt;&gt; getValidationGroups(RentalCar car) {\n"
      "        List&lt;Class&lt;?&gt;&gt; defaultGroupSequence = new ArrayList&lt;Class&lt;?&gt;&gt;();\n"
      "        defaultGroupSequence.add( RentalCar.class );\n"
      "\n"
      "        if ( car != null &amp;&amp; !car.isRented() ) {\n"
      "            defaultGroupSequence.add( CarChecks.class );\n"
      "        }\n"
      "\n"
      "        return defaultGroupSequence;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: title
#: usingvalidator.xml:732
#, no-c-format
msgid "Built-in constraints"
msgstr ""

#. Tag: para
#: usingvalidator.xml:734
#, no-c-format
msgid "Hibernate Validator comprises a basic set of commonly used constraints. These are foremost the constraints defined by the Bean Validation specification (see <xref linkend=\"table-spec-constraints\"/>). Additionally, Hibernate Validator provides useful custom constraints (see <xref linkend=\"table-custom-constraints\"/> and <xref linkend=\"table-custom-country-constraints\"/>)."
msgstr ""

#. Tag: title
#: usingvalidator.xml:742 usingvalidator.xml:761
#, no-c-format
msgid "Bean Validation constraints"
msgstr ""

#. Tag: para
#: usingvalidator.xml:744
#, no-c-format
msgid "shows purpose and supported data types of all constraints specified in the Bean Validation API. All these constraints apply to the field/property level, there are no class-level constraints defined in the Bean Validation specification. If you are using the Hibernate object-relational mapper, some of the constraints are taken into account when creating the DDL for your model (see column \"Hibernate metadata impact\")."
msgstr ""

#. Tag: para
#: usingvalidator.xml:753
#, no-c-format
msgid "Hibernate Validator allows some constraints to be applied to more data types than required by the Bean Validation specification (e.g. @Max can be applied to <classname>Strings</classname>). Relying on this feature can impact portability of your application between Bean Validation providers."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:774 usingvalidator.xml:1034 usingvalidator.xml:1232
#, no-c-format
msgid "Annotation"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:776 usingvalidator.xml:1036 usingvalidator.xml:1234
#, no-c-format
msgid "Supported data types"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:778 usingvalidator.xml:1038 usingvalidator.xml:1236
#, no-c-format
msgid "<entry>Use</entry>"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:780 usingvalidator.xml:1040 usingvalidator.xml:1240
#, no-c-format
msgid "Hibernate metadata impact"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:786
#, no-c-format
msgid "@AssertFalse"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:788 usingvalidator.xml:800
#, no-c-format
msgid "<classname>Boolean</classname>, <classname>boolean</classname>"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:791
#, no-c-format
msgid "Checks that the annotated element is <constant>false</constant>."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:794 usingvalidator.xml:806 usingvalidator.xml:826 usingvalidator.xml:846 usingvalidator.xml:882 usingvalidator.xml:940 usingvalidator.xml:956 usingvalidator.xml:969 usingvalidator.xml:996 usingvalidator.xml:1056 usingvalidator.xml:1070 usingvalidator.xml:1107 usingvalidator.xml:1120 usingvalidator.xml:1133 usingvalidator.xml:1149 usingvalidator.xml:1166 usingvalidator.xml:1183 usingvalidator.xml:1201 usingvalidator.xml:1256 usingvalidator.xml:1270 usingvalidator.xml:1285
#, no-c-format
msgid "none"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:798
#, no-c-format
msgid "@AssertTrue"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:803
#, no-c-format
msgid "Checks that the annotated element is <constant>true</constant>."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:810
#, no-c-format
msgid "@DecimalMax"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:812 usingvalidator.xml:852
#, no-c-format
msgid "<classname>BigDecimal</classname>, <classname>BigInteger</classname>, <classname>String</classname>, <classname>byte</classname>, <classname>short</classname>, <classname>int</classname>, <classname>long</classname> and the respective wrappers of the primitive types. Additionally supported by HV: any sub-type of <classname>Number</classname> and <classname>CharSequence</classname>."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:821
#, no-c-format
msgid "The annotated element must be a number whose value must be lower or equal to the specified maximum. The parameter value is the string representation of the max value according to the <classname>BigDecimal</classname> string representation."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:830
#, no-c-format
msgid "@DecimalMin"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:832
#, no-c-format
msgid "<classname>BigDecimal</classname>, <classname>BigInteger</classname>, <classname>String</classname>, <classname>byte</classname>, <classname>short</classname>, <classname>int</classname>, <classname>long</classname> and the respective wrappers of the primitive types. Additionally supported by HV: any sub-type of <classname>Number </classname>and <classname>CharSequence</classname>."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:841
#, no-c-format
msgid "The annotated element must be a number whose value must be higher or equal to the specified minimum. The parameter value is the string representation of the min value according to the <classname>BigDecimal</classname> string representation."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:850
#, no-c-format
msgid "@Digits(integer=, fraction=)"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:861
#, no-c-format
msgid "Checks whether the annoted value is a number having up to <literal>integer</literal> digits and <literal>fraction</literal> fractional digits."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:865
#, no-c-format
msgid "Define column precision and scale."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:869
#, no-c-format
msgid "@Future"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:871 usingvalidator.xml:946
#, no-c-format
msgid "<classname>java.util.Date</classname>, <classname>java.util.Calendar</classname>; Additionally supported by HV, if the <ulink url=\"http://joda-time.sourceforge.net/\">Joda Time</ulink> date/time API is on the class path: any implementations of <classname>ReadablePartial</classname> and <classname>ReadableInstant</classname>."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:879
#, no-c-format
msgid "Checks whether the annotated date is in the future."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:886
#, no-c-format
msgid "@Max"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:888
#, no-c-format
msgid "<classname>BigDecimal</classname>, <classname>BigInteger</classname>, <classname>byte</classname>, <classname>short</classname>, <classname>int</classname>, <classname>long</classname> and the respective wrappers of the primitive types. Additionally supported by HV: any sub-type of<classname>CharSequence</classname> (the numeric value represented by the character sequence is evaluated), any sub-type of <classname>Number</classname>."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:897
#, no-c-format
msgid "Checks whether the annotated value is less than or equal to the specified maximum."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:900 usingvalidator.xml:918
#, no-c-format
msgid "Add a check constraint on the column."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:904
#, no-c-format
msgid "@Min"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:906
#, no-c-format
msgid "<classname>BigDecimal</classname>, <classname>BigInteger</classname>, <classname>byte</classname>, <classname>short</classname>, <classname>int</classname>, <classname>long</classname> and the respective wrappers of the primitive types. Additionally supported by HV: any sub-type of <classname>CharSequence</classname> (the numeric value represented by the char sequence is evaluated), any sub-type of <classname>Number</classname>."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:915
#, no-c-format
msgid "Checks whether the annotated value is higher than or equal to the specified minimum."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:922
#, no-c-format
msgid "@NotNull"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:924 usingvalidator.xml:935 usingvalidator.xml:1172
#, no-c-format
msgid "Any type"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:926
#, no-c-format
msgid "Checks that the annotated value is not <constant>null.</constant>"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:929
#, no-c-format
msgid "Column(s) are not null."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:933
#, no-c-format
msgid "@Null"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:937
#, no-c-format
msgid "Checks that the annotated value is <constant>null.</constant>"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:944
#, no-c-format
msgid "@Past"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:954
#, no-c-format
msgid "Checks whether the annotated date is in the past."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:960
#, no-c-format
msgid "@Pattern(regex=, flag=)"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:962
#, no-c-format
msgid "<classname>String</classname>. Additionally supported by HV: any sub-type of <classname>CharSequence</classname>."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:965
#, no-c-format
msgid "Checks if the annotated string matches the regular expression <parameter>regex</parameter> considering the given flag <parameter>match</parameter>."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:973
#, no-c-format
msgid "@Size(min=, max=)"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:975
#, no-c-format
msgid "<classname>String</classname>, <classname>Collection</classname>, <classname>Map</classname> and <classname>arrays</classname>. Additionally supported by HV: any sub-type of <classname>CharSequence</classname>."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:980
#, no-c-format
msgid "Checks if the annotated element's size is between min and max (inclusive)."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:983 usingvalidator.xml:1082
#, no-c-format
msgid "Column length will be set to max."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:987
#, no-c-format
msgid "@Valid"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:989
#, no-c-format
msgid "Any non-primitive type"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:991
#, no-c-format
msgid "Performs validation recursively on the associated object. If the object is a collection or an array, the elements are validated recursively. If the object is a map, the value elements are validated recursively."
msgstr ""

#. Tag: para
#: usingvalidator.xml:1003
#, no-c-format
msgid "On top of the parameters indicated in <xref linkend=\"table-spec-constraints\"/> each constraint supports the parameters <parameter>message</parameter>, <parameter>groups</parameter> and <parameter>payload</parameter>. This is a requirement of the Bean Validation specification."
msgstr ""

#. Tag: title
#: usingvalidator.xml:1012
#, no-c-format
msgid "Additional constraints"
msgstr ""

#. Tag: para
#: usingvalidator.xml:1014
#, no-c-format
msgid "In addition to the constraints defined by the Bean Validation API Hibernate Validator provides several useful custom constraints which are listed in <xref linkend=\"table-custom-constraints\"/>. With one exception also these constraints apply to the field/property level, only @ScriptAssert is a class-level constraint."
msgstr ""

#. Tag: title
#: usingvalidator.xml:1021
#, no-c-format
msgid "Custom constraints"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1046
#, no-c-format
msgid "@CreditCardNumber"
msgstr ""

#. Tag: classname
#: usingvalidator.xml:1048 usingvalidator.xml:1062 usingvalidator.xml:1076 usingvalidator.xml:1089 usingvalidator.xml:1113 usingvalidator.xml:1155 usingvalidator.xml:1189 usingvalidator.xml:1248 usingvalidator.xml:1262 usingvalidator.xml:1276
#, no-c-format
msgid "CharSequence"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1050
#, no-c-format
msgid "Checks that the annotated character sequence passes the Luhn checksum test. Note, this validation aims to check for user mistakes, not credit card validity! See also <ulink url=\"http://www.merriampark.com/anatomycc.htm\">Anatomy of Credit Card Numbers</ulink>."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1060
#, no-c-format
msgid "@Email"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1064
#, no-c-format
msgid "Checks whether the specified character sequence is a valid email address. The optional parameters <parameter>regexp</parameter> and <parameter>flags</parameter> allow to specify an additional regular expression (including regular expression flags) which the email must match."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1074
#, no-c-format
msgid "@Length(min=, max=)"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1078
#, no-c-format
msgid "Validates that the annotated character sequence is between <parameter>min</parameter> and <parameter>max</parameter> included."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1086
#, no-c-format
msgid "@ModCheck(modType=, multiplier=, startIndex=, endIndex=, checkDigitPosition=, ignoreNonDigitCharacters=)"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1091
#, no-c-format
msgid "Checks that the digits within the annotated character sequence pass the mod 10 or mod 11 checksum algorithm. <constant>modType</constant> is used to select the modulo type and the <constant>multiplier</constant> determines the algorithm specific multiplier (see also <ulink url=\"http://en.wikipedia.org/wiki/Luhn_algorithm\">Luhn algorithm</ulink>). <constant>startIndex</constant> and <constant>endIndex</constant> allow to only run the modulo algorithm on the specified sub-string. <constant>checkDigitPosition</constant> allows to use an arbitrary digit within the character sequence to be the check digit. If not specified it is assumed that the check digit is part of the specified range. Last but not least, <constant>ignoreNonDigitCharacters</constant> allows to ignore non digit characters."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1111
#, no-c-format
msgid "@NotBlank"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1115
#, no-c-format
msgid "Checks that the annotated character sequence is not null and the trimmed length is greater than 0. The difference to @NotEmpty is that this constraint can only be applied on strings and that trailing whitespaces are ignored."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1124
#, no-c-format
msgid "@NotEmpty"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1126
#, no-c-format
msgid "<classname>CharSequence</classname>, <classname>Collection</classname>, <classname>Map</classname> and arrays"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1130
#, no-c-format
msgid "Checks whether the annotated element is not <constant>null</constant> nor empty."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1137
#, no-c-format
msgid "@Range(min=, max=)"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1139
#, no-c-format
msgid "<classname>BigDecimal</classname>, <classname>BigInteger</classname>, <classname>CharSequence</classname>, <classname>byte</classname>, <classname>short</classname>, <classname>int</classname>, <classname>long</classname> and the respective wrappers of the primitive types"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1146
#, no-c-format
msgid "Checks whether the annotated value lies between (inclusive) the specified minimum and maximum."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1153
#, no-c-format
msgid "@SafeHtml(whitelistType=, additionalTags=)"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1157
#, no-c-format
msgid "Checks whether the annotated value contains potentially malicious fragments such as <code>&lt;script/&gt;</code>. In order to use this constraint, the <ulink url=\"http://jsoup.org/\">jsoup</ulink> library must be part of the class path. With the <parameter>whitelistType</parameter> attribute predefined whitelist types can be chosen. You can also specify additional html tags for the whitelist with the <parameter>additionalTags</parameter> attribute."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1170
#, no-c-format
msgid "@ScriptAssert(lang=, script=, alias=)"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1174
#, no-c-format
msgid "Checks whether the given script can successfully be evaluated against the annotated element. In order to use this constraint, an implementation of the Java Scripting API as defined by JSR 223 (\"Scripting for the Java<superscript>TM</superscript> Platform\") must part of the class path. The expressions to be evaluated can be written in any scripting or expression language, for which a JSR 223 compatible engine can be found in the class path."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1187
#, no-c-format
msgid "@URL(protocol=, host=, port=, regexp=, flags=)"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1191
#, no-c-format
msgid "Checks if the annotated character sequence is a valid URL according to RFC2396. If any of the optional parameters <parameter>protocol</parameter>, <parameter>host</parameter> or <parameter>port</parameter> are specified, the corresponding URL fragments must match the specified values. The optional parameters <parameter>regexp</parameter> and <parameter>flags</parameter> allow to specify an additional regular expression (including regular expression flags) which the URL must match."
msgstr ""

#. Tag: title
#: usingvalidator.xml:1208
#, no-c-format
msgid "Country specific constraints"
msgstr ""

#. Tag: para
#: usingvalidator.xml:1210
#, no-c-format
msgid "Hibernate Validator offers also some country specific constraints, e.g. for the validation of social security numbers."
msgstr ""

#. Tag: para
#: usingvalidator.xml:1212
#, no-c-format
msgid "If you have to implement a country specific constraint, consider making it a contribution to Hibernate Validator!"
msgstr ""

#. Tag: title
#: usingvalidator.xml:1217
#, no-c-format
msgid "Custom country specific constraints"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1238
#, no-c-format
msgid "Country"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1246
#, no-c-format
msgid "@CNPJ"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1250
#, no-c-format
msgid "Checks that the annotated character sequence represents a Brazilian corporate tax payer registry number (Cadastro de Pessoa Juríeddica)"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1254 usingvalidator.xml:1268 usingvalidator.xml:1283
#, no-c-format
msgid "Brazil"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1260
#, no-c-format
msgid "@CPF"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1264
#, no-c-format
msgid "Checks that the annotated character sequence represents a Brazilian individual taxpayer registry number (Cadastro de Pessoa Fídsica)."
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1274
#, no-c-format
msgid "@TituloEleitoral"
msgstr ""

#. Tag: entry
#: usingvalidator.xml:1278
#, no-c-format
msgid "Checks that the annotated character sequence represents a Brazilian voter ID card number (<ulink url=\"http://ghiorzi.org/cgcancpf.htm\">Título Eleitoral</ulink>)."
msgstr ""

#. Tag: para
#: usingvalidator.xml:1292
#, no-c-format
msgid "In some cases neither the Bean Validation constraints nor the custom constraints provided by Hibernate Validator will fulfill your requirements. In this case you can easily write your own constraint. We will discuss this in <xref linkend=\"validator-customconstraints\"/>."
msgstr ""

